// Acquire VS Code API
const vscode = acquireVsCodeApi();

// Get data injected from the extension
const lyric = window.posterData.lyric;
const bgSrc = window.posterData.bgSrc;

const canvas = document.getElementById('posterCanvas');
const ctx = canvas.getContext('2d');

// --- State Management ---
const state = {
    img: null,
    isLoaded: false,
    x: 0,
    y: 0,
    scale: 1,
    isDragging: false,
    lastMouseX: 0,
    lastMouseY: 0
};

// --- Initialization ---

// Load Image
const img = new Image();
img.src = bgSrc;
img.onload = () => {
    state.img = img;
    state.isLoaded = true;
    
    // Initial Fit: Cover
    fitImageToCover();
    draw();
};
img.onerror = () => {
    draw(); // Draw fallback
}

// --- Interaction Events ---

canvas.addEventListener('mousedown', (e) => {
    if (!state.isLoaded) return;
    state.isDragging = true;
    state.lastMouseX = e.offsetX;
    state.lastMouseY = e.offsetY;
    canvas.style.cursor = 'grabbing';
});

window.addEventListener('mouseup', () => {
    state.isDragging = false;
    canvas.style.cursor = 'grab';
});

canvas.addEventListener('mousemove', (e) => {
    if (!state.isDragging) return;
    
    const dx = e.offsetX - state.lastMouseX;
    const dy = e.offsetY - state.lastMouseY;
    
    state.x += dx;
    state.y += dy;
    
    state.lastMouseX = e.offsetX;
    state.lastMouseY = e.offsetY;
    
    requestAnimationFrame(draw);
});

canvas.addEventListener('wheel', (e) => {
    if (!state.isLoaded) return;
    e.preventDefault();

    const zoomIntensity = 0.1;
    const delta = e.deltaY < 0 ? 1 : -1;
    const newScale = state.scale + (delta * zoomIntensity);

    // Limit zoom
    if (newScale > 0.1 && newScale < 10) {
        // Zoom towards center logic (simplified: just scale)
        // Ideally we zoom towards mouse, but center zoom is easier for now
        // To keep image centered while zooming:
        // current_center_x = (canvas_w/2 - x) / scale
        
        // Let's implement simple center zoom for stability
        const canvasCenterX = canvas.width / 2;
        const canvasCenterY = canvas.height / 2;
        
        // Calculate offset based on scale change to keep center fixed
        state.x = canvasCenterX - (canvasCenterX - state.x) * (newScale / state.scale);
        state.y = canvasCenterY - (canvasCenterY - state.y) * (newScale / state.scale);
        
        state.scale = newScale;
        requestAnimationFrame(draw);
    }
});

// Set initial cursor
canvas.style.cursor = 'grab';

// --- Logic ---

function fitImageToCover() {
    if (!state.img) return;
    
    const canvasRatio = canvas.width / canvas.height;
    const imgRatio = state.img.width / state.img.height;
    
    if (imgRatio > canvasRatio) {
        // Image is wider: Match height
        state.scale = canvas.height / state.img.height;
        state.x = (canvas.width - state.img.width * state.scale) / 2;
        state.y = 0;
    } else {
        // Image is taller: Match width
        state.scale = canvas.width / state.img.width;
        state.x = 0;
        state.y = (canvas.height - state.img.height * state.scale) / 2;
    }
}

function draw() {
    // 1. Clear & Background Fill
    ctx.fillStyle = '#2d2d2d';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 2. Draw Image with Transform
    if (state.isLoaded && state.img) {
        ctx.save();
        ctx.translate(state.x, state.y);
        ctx.scale(state.scale, state.scale);
        ctx.drawImage(state.img, 0, 0);
        ctx.restore();
    }

    // 3. Draw Overlay & Text (Static)
    drawOverlay();
    drawText();
}

function drawOverlay() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; // Slightly lighter for editing visibility
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawText() {
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // 4. Lyric Text
    ctx.font = 'bold 36px "Microsoft YaHei", sans-serif';
    
    // Shadow for better readability over complex images
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    wrapText(ctx, lyric.content, 300, 320, 450, 60);

    // Reset shadow
    ctx.shadowColor = 'transparent';

    // 5. Song Info
    ctx.fillStyle = '#dddddd';
    ctx.font = '22px sans-serif';
    ctx.fillText('—— ' + lyric.song + ' ——', 300, 580);
    ctx.font = '16px sans-serif';
    ctx.fillText('Album: ' + lyric.album, 300, 615);

    // 6. Footer
    ctx.fillStyle = '#FFD700'; 
    ctx.font = 'italic 14px sans-serif';
    ctx.fillText('Generated by Eason Code VSCode Extension', 300, 750);
}

function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const chars = text.split('');
    let line = '';
    let currentY = y;

    for(let n = 0; n < chars.length; n++) {
        const testLine = line + chars[n];
        const metrics = context.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
            context.fillText(line, x, currentY);
            line = chars[n];
            currentY += lineHeight;
        } else {
            line = testLine;
        }
    }
    context.fillText(line, x, currentY);
}

// Initial Draw Call
draw();

// Reset Action
document.getElementById('resetBtn').addEventListener('click', () => {
    fitImageToCover();
    draw();
});

// Save Action
document.getElementById('saveBtn').addEventListener('click', () => {
    const dataUrl = canvas.toDataURL('image/png');
    vscode.postMessage({
        command: 'savePoster',
        data: dataUrl
    });
});
